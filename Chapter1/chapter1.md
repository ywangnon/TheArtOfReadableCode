# 1. 코드는 이해하기 쉬워야 한다

## 무엇이 코드를 ‘더 좋게’ 만드는가?

좋은 코드는 **간결함**과 **친숙함**의 균형을 이룹니다.

* **간결함**: 짧고 한 줄에 표현된 코드는 효율적으로 보일 수 있습니다.

```c
return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / (1 << -exponent);
```

* **친숙함**: 하지만 명확한 구조와 흐름을 가진 코드는 더 쉽게 이해됩니다.

```c
if (exponent >= 0) {
  return mantissa * (1 << exponent);
} else {
  return mantissa / (1 << -exponent);
}
```

간결한 코드보다 **직관적인 코드**가 유지보수에 유리합니다.

---

## 가독성의 기본 원칙

> **좋은 코드는 다른 사람이 그것을 이해하는 데 걸리는 시간을 최소화한다.**

* ‘이해’란 단순히 읽는 것이 아니라,

  * **수정할 수 있고**
  * **변경이 다른 코드에 미치는 영향을 예측할 수 있는 상태**를 의미합니다.

---

## 코드의 분량이 적으면 항상 더 좋은가?

### 예시:

1. 축약된 코드:

```c
assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());
```

2. 풀어쓴 코드:

```c
bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket->IsOccupied());
```

→ **2번 코드가 더 길지만, 읽고 이해하는 데 더 적은 시간이 걸릴 수 있습니다.**

* 요점: 코드의 분량보다 **이해를 위한 시간**이 더 중요합니다.

---

## 주석은 코드의 이해를 돕는다

주석은 코드의 맥락이나 목적을 설명해 줍니다.

```c
// "hash = (65599 * hash) + c"의 빠른 계산 버전
hash = (hash << 6) + (hash << 16) - hash + c;
```

* 이처럼 **복잡한 연산이나 의도를 설명하는 주석**은 코드 자체보다 훨씬 큰 가치를 가질 수 있습니다.

---

## 이해하기 쉬운 코드는 다른 목표와 충돌하지 않는다

* **성능**
* **아키텍처**
* **테스트 용이성**

이러한 요소들과 **이해하기 쉬운 코드**는 서로 **충돌하지 않습니다**.

> 오히려 명확한 코드는 이러한 요소들을 더 잘 달성할 수 있게 도와줍니다.

---

## 실질적인 어려움

* 다른 사람이 이해하기 쉬운 코드를 쓰려면 **추가적인 시간과 노력**이 필요합니다.
* 하지만 이 노력은 장기적인 유지보수성과 협업 효율성에서 **큰 차이를 만들어냅니다.**

---

**결론:**

> 코드를 짧게 쓰는 것보다, **이해하기 쉽게 쓰는 것이 더 중요하다.**
> 
> 좋은 코드는 누구나 빠르게 읽고, 안전하게 수정할 수 있어야 한다.
